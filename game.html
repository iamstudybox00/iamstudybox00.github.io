<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>몬스터 웨이브 디펜스</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {margin:0;padding:0;box-sizing:border-box;}
    body {
      margin:0; background:linear-gradient(135deg,#1a1a2e 0%,#0f0f1e 100%);
      min-height:100vh; display:flex; flex-direction:column; align-items:center;
      font-family:Arial,sans-serif; color:#fff; padding:20px;
    }
    h1 {margin:10px 0; font-size:2em; text-shadow:0 0 20px #00ffff;}
    #ui {
      display:flex; gap:20px; margin:10px 0; font-size:1.1em;
      background:rgba(0,0,0,.6); padding:12px 24px; border-radius:12px;
    }
    #ui > div {display:flex;align-items:center;gap:8px;}
    #hpBar {width:200px;height:20px;background:#333;border:2px solid #fff;border-radius:10px;overflow:hidden;}
    #hpFill {height:100%;background:linear-gradient(90deg,#ff0000,#ff9900,#00ff00);transition:width .3s;}
    canvas {border:3px solid #00ffff; border-radius:12px; background:#000;box-shadow:0 0 30px #00ffff66;}
    button {
      margin-top:12px; padding:12px 32px; background:#00ffff; color:#000;
      border:none; border-radius:8px; font-size:1.1em; font-weight:700; cursor:pointer;
      box-shadow:0 4px 12px #00ffff88; transition:all .2s; display:none;
    }
    button:hover {background:#00cccc; transform:scale(1.05);}
  </style>
</head>
<body>
  <h1>⚔️ 몬스터 웨이브 디펜스</h1>
  <div id="ui">
    <div>❤️ HP: <div id="hpBar"><div id="hpFill" style="width:100%;"></div></div></div>
    <div>📍 스테이지: <span id="stage">1</span></div>
    <div>🎯 처치: <span id="kills">0</span>/<span id="target">20</span></div>
    <div>💼 직업: <span id="job">전사</span></div>
  </div>
  <canvas id="game" width="900" height="600"></canvas>
  <div style="margin-top:10px;font-size:0.9em;">WASD: 이동 | 마우스: 공격 방향 | 스페이스: 필살기</div>
  <button id="restart">다시 시작</button>
<script>
const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
let frame=0, monsters=[], projectiles=[], effects=[], items=[], playing=true;
let stage=1, kills=0, targetKills=20, hp=100, maxHp=100, job='Warrior', ultCooldown=0;

class Player {
  constructor() { this.x=canvas.width/2; this.y=canvas.height-100; this.speed=4; this.keys={}; this.mouseX=0; this.mouseY=0; }
  draw() {
    const colors={Warrior:'#ff0000',Rogue:'#a855f7',Pirate:'#0066ff',Archer:'#00aa00'};
    ctx.fillStyle=colors[job]||'#ff0000'; ctx.fillRect(this.x-15,this.y-15,30,30);
    ctx.fillStyle='#fff'; ctx.fillText(job=='Warrior'?'⚔️':job=='Rogue'?'🗡️':job=='Pirate'?'🔫':'🏹',this.x-10,this.y+5);
    
    const angle=this.getAttackAngle();
    ctx.strokeStyle='#ffff00';
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(this.x,this.y);
    ctx.lineTo(this.x+Math.cos(angle)*25,this.y+Math.sin(angle)*25);
    ctx.stroke();
  }
  update() {
    if(this.keys['w'] || this.keys['W']) this.y-=this.speed;
    if(this.keys['s'] || this.keys['S']) this.y+=this.speed;
    if(this.keys['a'] || this.keys['A']) this.x-=this.speed;
    if(this.keys['d'] || this.keys['D']) this.x+=this.speed;
    this.x=Math.max(15,Math.min(canvas.width-15,this.x));
    this.y=Math.max(15,Math.min(canvas.height-15,this.y));
    this.draw();
  }
  getAttackAngle() {
    const dx=this.mouseX-this.x, dy=this.mouseY-this.y;
    return Math.atan2(dy,dx);
  }
}

class Monster {
  constructor() {
    const side=Math.floor(Math.random()*4);
    if(side==0) { this.x=Math.random()*canvas.width; this.y=-30; }
    else if(side==1) { this.x=canvas.width+30; this.y=Math.random()*canvas.height; }
    else if(side==2) { this.x=Math.random()*canvas.width; this.y=canvas.height+30; }
    else { this.x=-30; this.y=Math.random()*canvas.height; }
    this.hp=10+(stage-1)*10; this.maxHp=this.hp; this.speed=1+stage*0.2; this.size=20;
    this.lastDamage=0;
  }
  update() {
    const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
    this.x+=dx/dist*this.speed; this.y+=dy/dist*this.speed;
    const pdx=this.x-player.x, pdy=this.y-player.y;
    if(Math.sqrt(pdx*pdx+pdy*pdy)<30 && frame-this.lastDamage>30) {
      hp-=0.5; this.lastDamage=frame;
      if(hp<=0) { hp=0; setTimeout(()=>gameOver(),100); }
      effects.push({x:player.x,y:player.y,life:20,type:'hit'});
    }
    ctx.fillStyle='#ff3333'; ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size);
    ctx.fillStyle='#fff'; ctx.fillText('👾',this.x-8,this.y+5);
    ctx.fillStyle='#f00'; ctx.fillRect(this.x-this.size/2,this.y-this.size/2-10,this.size,4);
    ctx.fillStyle='#0f0'; ctx.fillRect(this.x-this.size/2,this.y-this.size/2-10,this.size*(this.hp/this.maxHp),4);
  }
}

class Projectile {
  constructor(x,y,angle,speed=5,type='normal') {
    this.x=x; this.y=y; this.angle=angle; this.speed=speed; this.type=type; this.dmg=10+stage;
  }
  update() {
    this.x+=Math.cos(this.angle)*this.speed; this.y+=Math.sin(this.angle)*this.speed;
    if(this.x<0 || this.x>canvas.width || this.y<0 || this.y>canvas.height) return false;
    for(let m of monsters) {
      const dx=this.x-m.x, dy=this.y-m.y, dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<20) { m.hp-=this.dmg; effects.push({x:m.x,y:m.y,life:15,type:'hit'}); 
        if(m.hp<=0) { kills++; if(Math.random()<0.5) { const newItem=new Item(m.x,m.y,['Warrior','Rogue','Pirate','Archer'][Math.floor(Math.random()*4)]); items.push(newItem); }
        monsters.splice(monsters.indexOf(m),1); } return false; }
    }
    ctx.fillStyle='#ffff00'; ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill();
    return true;
  }
}

class Item {
  constructor(x,y,type) { this.x=x; this.y=y; this.type=type; this.vx=(Math.random()-0.5)*2; this.vy=(Math.random()-0.5)*2; this.timer=0; }
  update() {
    this.timer++;
    const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<30) { 
      if(this.type=='Heal') { hp=Math.min(maxHp,hp+30); }
      else { job=this.type; ultCooldown=0; }
      items.splice(items.indexOf(this),1); return false; 
    }
    this.x+=this.vx; this.y+=this.vy;
    const icons={Warrior:'⚔️',Rogue:'🗡️',Pirate:'🔫',Archer:'🏹',Heal:'💚'};
    ctx.font='24px Arial'; ctx.fillText(icons[this.type]||'✨',this.x-12,this.y+8);
    return true;
  }
}

const player=new Player();

document.addEventListener('keydown',e=>{
  if(!playing) return;
  player.keys[e.key]=true;
  if(e.key==' ') { if(ultCooldown>=300) { ultCooldown=0; activateUlt(); } }
});

document.addEventListener('keyup',e=>{
  player.keys[e.key]=false;
});

canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();
  player.mouseX=e.clientX-rect.left;
  player.mouseY=e.clientY-rect.top;
});

function activateUlt() {
  if(job=='Warrior') {
    for(let r=0;r<3;r++) {
      for(let i=0;i<20;i++) {
        setTimeout(()=>{
          const angle=player.getAttackAngle()+Math.PI*2/20*i;
          for(let j=0;j<3;j++) {
            projectiles.push(new Projectile(player.x,player.y,angle+(j-1)*Math.PI/12,8,'ult'));
          }
        },r*500+i*30);
      }
    }
  } else if(job=='Rogue') {
    for(let r=0;r<15;r++) {
      setTimeout(()=>{
        const angle=player.getAttackAngle();
        for(let i=0;i<12;i++) {
          projectiles.push(new Projectile(player.x,player.y,angle+i*Math.PI*2/12,12,'ult'));
        }
      },r*80);
    }
  } else if(job=='Pirate') {
    for(let i=0;i<40;i++) {
      setTimeout(()=>{
        const tx=Math.random()*canvas.width, ty=Math.random()*canvas.height;
        effects.push({x:tx,y:ty,life:40,type:'bomb'});
        for(let m of [...monsters]) {
          const dx=m.x-tx, dy=m.y-ty; if(Math.sqrt(dx*dx+dy*dy)<100) m.hp-=80;
          if(m.hp<=0) { kills++; monsters.splice(monsters.indexOf(m),1); }
        }
      },i*60);
    }
  } else if(job=='Archer') {
    for(let i=0;i<50;i++) {
      const tx=Math.random()*canvas.width, ty=Math.random()*canvas.height;
      setTimeout(()=>{projectiles.push(new Projectile(tx,-10,Math.PI/2,15,'ult'));},i*50);
      setTimeout(()=>{projectiles.push(new Projectile(tx,canvas.height+10,-Math.PI/2,15,'ult'));},i*50);
      setTimeout(()=>{projectiles.push(new Projectile(-10,ty,0,15,'ult'));},i*50);
      setTimeout(()=>{projectiles.push(new Projectile(canvas.width+10,ty,Math.PI,15,'ult'));},i*50);
    }
  }
}

function attack() {
  let attackRate = 30;
  if(job=='Rogue') attackRate = 15;
  if(job=='Pirate') attackRate = 25;
  if(job=='Archer') attackRate = 20;
  
  if(frame%attackRate!=0) return;
  
  const baseAngle = player.getAttackAngle();
  
  if(job=='Warrior') {
    for(let i=-1;i<=1;i++) {
      projectiles.push(new Projectile(player.x,player.y,baseAngle+i*Math.PI/4,4));
    }
  } else if(job=='Rogue') {
    for(let i=0;i<3;i++) {
      projectiles.push(new Projectile(player.x,player.y,baseAngle+i*Math.PI*2/3-Math.PI/3,8));
    }
  } else if(job=='Pirate') {
    for(let i=-1;i<=1;i++) {
      projectiles.push(new Projectile(player.x,player.y,baseAngle+i*Math.PI/8,6));
    }
  } else if(job=='Archer') {
    for(let i=-1;i<=1;i++) {
      projectiles.push(new Projectile(player.x,player.y,baseAngle+i*Math.PI/6,7));
    }
  }
}

function gameLoop() {
  if(!playing) return;
  ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  frame++;
  ultCooldown++;
  
  attack();
  
  if(frame%120===0 && monsters.length<30) { for(let i=0;i<2+stage;i++) monsters.push(new Monster()); }
  
  if(stage>=5 && frame%600===0 && Math.random()<0.15) {
    items.push(new Item(Math.random()*canvas.width,Math.random()*canvas.height,'Heal'));
  }
  
  player.update();
  for(let m of [...monsters]) m.update();
  for(let p of [...projectiles]) { if(!p.update()) projectiles.splice(projectiles.indexOf(p),1); }
  for(let i=items.length-1;i>=0;i--) { if(!items[i].update()) items.splice(i,1); }
  for(let e of effects) {
    e.life--;
    if(e.type=='hit') { ctx.fillStyle='#ffff00'; ctx.beginPath(); ctx.arc(e.x,e.y,10-e.life/2,0,Math.PI*2); ctx.fill(); }
    if(e.type=='bomb') { ctx.fillStyle='#ff8800'; ctx.beginPath(); ctx.arc(e.x,e.y,e.life,0,Math.PI*2); ctx.fill(); }
    if(e.life<=0) effects.splice(effects.indexOf(e),1);
  }
  
  if(kills>=targetKills) { stage++; kills=0; targetKills=20+stage*10; hp=maxHp; monsters=[]; }
  
  document.getElementById('stage').textContent=stage;
  document.getElementById('kills').textContent=kills;
  document.getElementById('target').textContent=targetKills;
  document.getElementById('hpFill').style.width=(hp/maxHp*100)+'%';
  const jobNames={Warrior:'전사',Rogue:'도적',Pirate:'해적',Archer:'궁수'};
  document.getElementById('job').textContent=jobNames[job]||'전사';
  
  ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.fillRect(10,canvas.height-30,250,20);
  if(ultCooldown<300) ctx.fillStyle='#00ffff'; else ctx.fillStyle='#0f0';
  ctx.fillRect(10,canvas.height-30,Math.min(ultCooldown/300*250,250),20);
  
  requestAnimationFrame(gameLoop);
}

function gameOver() {
  playing=false;
  ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#fff'; ctx.font='48px Arial'; ctx.textAlign='center';
  ctx.fillText('게임 오버!',canvas.width/2,canvas.height/2);
  ctx.font='24px Arial'; ctx.fillText(`최종 스테이지: ${stage}`,canvas.width/2,canvas.height/2+50);
  document.getElementById('restart').style.display='block';
}

function startGame() {
  playing=true; stage=1; kills=0; targetKills=20; hp=100; job='Warrior'; monsters=[]; projectiles=[]; effects=[]; items=[]; frame=0;
  document.getElementById('restart').style.display='none';
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  gameLoop();
}

document.getElementById('restart').onclick=startGame;
startGame();
</script>
</body>
</html>